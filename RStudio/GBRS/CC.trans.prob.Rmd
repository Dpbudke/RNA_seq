---
title: "CC.trans.prob"
output: html_notebook
---

This markdown was generated from Mike Lloyd's "cc.trans.prob.R" R script he emailed me after we discussed my need for CC specific transition probability files in order to complete the GBRS functions to generate diplotypes for CC/CC-RIX allele-specific-expression.

**Load Packages**

```{r}
#library(rtracklayer)
 library(optparse)
 library(dplyr)
 library(rhdf5)
 library(parallel)
library(dplyr)
library(testthat)
library(reticulate)  # For reading NPZ files
library(tidyverse)   # For data manipulation and visualization
library(pheatmap)    # For creating heatmaps
library(Matrix)      # For matrix operations
library(reshape2)
library(biomaRt)
library(mmconvert)
library(openxlsx)
```

```{r}
# Mike Lloyd's original code 
### "couldn’t complete the script for all genes, nor did I try to extend from 8 to 36 state matrices" 

cc.trans.probs_2 = function(snps, chr = c(1:19, "X")) {

  if(chr != 'X') {

    curr.snps = which(snps[,2] == chr)
    retval = array(0, c(length(1:8), length(1:8), length(curr.snps) - 1), dimnames =
                     list(c('A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'), c('A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'), genes[curr.snps[-1], 1]))
    r = diff(snps[curr.snps, 4]) * 1e-8
    r[r == 0] = 1e-8  # We can't have zero values here, so set them very small.

    for(s in 1:(length(curr.snps)-1)) {
      # // equations are from Broman (2005) Genetics 169:1133-1146
      # //    doi:10.1534/genetics.104.035212
      # //    see bottom equation in right column on page 1137
      # //    (need to multiply by 8 to get conditional probabilities,
      # //     and note that there was an error in the i != j case)
      retval[,,s] = log(r[s]) - log(1.0 + 6.0 * r[s])
      diag(retval[,,s]) = log(1.0 - r[s]) - log(1.0 + 6.0 * r[s])
    } # for s in genes/snps

  } else { # no-autosomal genes
    # // X chr; need to use founder order
    # // equations are from Broman (2005) Genetics 169:1133-1146
    # //    doi:10.1534/genetics.104.035212
    # //    see table 4 page 1137
    # //    (need to multiply by the marginal probability, 1/6 or 1/3,
    # //     to get these conditional probabilities)

    curr.snps = which(snps[,2] == chr)

    print(curr.snps)

    retval = array(0, c(length(1:5), length(1:5), length(curr.snps) - 1), dimnames =
                     list(c('A', 'B', 'C', 'E', 'F'), c('A', 'B', 'C', 'E', 'F'), genes[curr.snps[-1], 1]))

    ## // X chromosome (can be A, B, C, E, F but not D, G, H) https://github.com/rqtl/qtl2/blob/main/src/cross_risib8.cpp#L28C10-L28C66
    genotype <- c('A', 'B', 'C', 'E', 'F')

    r = diff(snps[curr.snps, 4]) * 1e-8
    r[r == 0] = 1e-8  # We can't have zero values here, so set them very small.
    for(s in 1:(length(curr.snps)-1)) {
      for (i in 1:nrow(retval[,,s])) {
        for (j in 1:ncol(retval[,,s])){
          # row == column
          if (genotype[i] == genotype[j]) {
            # check if 'C' genotype as conditonal prob differs in this case
            if (genotype[i] == genotype[3]) {
              retval[,,s][i,j] = - log(1.0 + 4.0 * r[s])
              # else use the following diagonal
            } else {
              retval[,,s][i,j] = log(1.0 - r[s]) - log(1.0 + 4.0 * r[s])
            }
            ## If col == 'C'
          } else if (genotype[j] == genotype[3]) {
            retval[,,s][i,j] = log(2.0) + log(r[s]) - log(1.0 + 4.0 * r[s])
            ## Else fill the matrix
          } else {
            retval[,,s][i,j] = log(r[s]) - log(1.0 + 4.0 * r[s])
          }
        }
      }
    } # for s in genes/snps
  }
  return(retval)
}

genes <- data.frame(marker = c('ENSMUSG00000102693', 'ENSMUSG00000064842', 'ENSMUSG00000051951', 'ENSMUSG00000102612', 'ENSMUSG00000064842', 'ENSMUSG00000051951'),
                    chr = c('1', '1', '1', 'X', 'X', 'X'),
                    pos = c(3143476, 3172239, 3276124, 3143476, 3172239, 3276124),
                    cM = c(0.0725, 0.0871, 0.1376, 0.0725, 0.0871, 0.1376))


#cc.trans.probs_2(genes,  chr="1")

cc.trans.probs_2(genes,  chr="X")

```

## 1. Load in annotation

```{r}
# oddly, only the Ensemble v105 isn't working.. its even dead on their website, while all other archived versions are fine 

#option_list = list(
   # make_option(c("-e", "--ensembl_build"), type="character", default="105", 
              #help="Ensembl build version [default= %default]", metavar="105"),
   # make_option(c("-g", "--num_generation"), type="character", default="100",
            #  help="Number of generations to calculate [default= %default]"),
   # make_option(c("-o", "--output_prefix"), type="character", default="tranprob.genes.DO.", 
             # help="output prefix [default= %default]")
#); 

#opt_parser = OptionParser(option_list=option_list);
#opt = parse_args(opt_parser);

#Sys.setenv(BIOMART_CACHE=tempdir())

################################################################################

## Obtain geneIDs, and positions from biomaRt.

#ensembl_mart <- useEnsembl(biomart = 'genes',
                        #dataset = 'mmusculus_gene_ensembl',
                       # version = opt$ensembl_build,
                       # mirror = "uswest") 
                        ## note: I have seen issues with timeout: "Error in curl::curl_fetch_memory(url, handle = handle) : Timeout was reached: [www.ensembl.org:443] Operation timed out after 10001 milliseconds with 0 bytes received"
                        ##       useast seems to be more stable. Other options are: useast, uswest, asia, and www. A try/except catch could be added to retry on a different mirror if this is a highly recurrent issue. 

#attributes <- searchAttributes(mart = ensembl_mart)

#genes.with.id=getBM(attributes=c("ensembl_gene_id", "chromosome_name", "start_position", "end_position", "strand", "external_gene_name", "gene_biotype"), mart = ensembl_mart)

# Save the dataframe as an RDS file
#saveRDS(genes.with.id, file = "genes_with_id.rds")
# Load the dataframe from the RDS file
genes.with.id <- readRDS("Data/genes_with_id.rds") # this directly reads in 105 

```

## 2. Prepare DF

```{r}
#Prepping the DF 
#gene_bp_to_cM_to_transprob.R

## Convert bp to cM positions using mmconvert.

valid_chr = c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 'X')

input_df <- genes.with.id %>%
              dplyr::filter(chromosome_name %in% valid_chr) %>%
              dplyr::rename(marker = ensembl_gene_id, chr = chromosome_name, pos = start_position) %>%
              dplyr::select(chr, pos, marker)
## mmconvert requires the columns: c(chr, pos, marker).

table(genes.with.id$chromosome_name)
## check gene counts by chr.
table(input_df$chr)
## check gene counts by chr.

converted_df <- mmconvert(input_df, input_type = 'bp')
## convert to cM from bp

jittered_converted_df <- converted_df %>%
                          dplyr::mutate(cM = round(ifelse(is.na(cM_coxV3_ave), cM_coxV3_female, cM_coxV3_ave), digits = 4)) %>%
                                          # catch cases where average cM isn't present (e.g., chrX)
                          dplyr::arrange(chr, cM) %>%
                          group_by(chr, cM) %>%
                                          # sort on chr and position (i.e., cM)
                          dplyr::mutate(group_count = n(), row_num = row_number() - 1) %>%
                          dplyr::mutate(jittered_cM = cM + (0.000001 * (row_number() - 1))) %>%
                                          # set a jitter cM value. Where a constant is added to sequential members of the group. Corrects for genes with identical positions.
                          ungroup() %>%
                          dplyr::arrange(chr, jittered_cM) %>%
                          as.data.frame()
## Jitter cM positions that are identical.

#Note: this is where they combined with Y/MT, but inbred CC have consistent Y/MT, so not necessary to include 
valid_chr_jittered <- jittered_converted_df %>% dplyr::select(marker, chr, bp_grcm39, jittered_cM) %>% dplyr::rename(pos = bp_grcm39)

#write.table(valid_chr_jittered, file = paste0('gene_list_ensemblBuild_', opt$ensembl_build,".tsv"), sep="\t", row.names = FALSE, quote=FALSE)

# First rename valid_chr_jittered to snps for consistency with our functions
snps <- valid_chr_jittered %>%
        dplyr::rename(cM = jittered_cM)  # rename to match expected column name
```

## 3. Make CC strain haplotype indexes

```{r}
# taking all "Control" Pups samples GBRS haplotype output, confiriming concordance, then generating index which I can incorporate into CC-RIX transprob generation  

ControlPup <- read.xlsx("Data/Data4R_db_03042024_FINAL.xlsx", sheet = "ControlPups", na.strings = c(""," ","NA","N/A","na", "n/a"), skipEmptyRows = TRUE)

#Add Cross column in ControlPup df
ControlPup$Cross <- paste0(ControlPup$CC.Mom.Strain, " x ", ControlPup$CC.Dad.Strain)

# Read in the data files
combined_haplotypes <- read.csv("Data/Final_counts/combined_haplotypes.csv")
names(combined_haplotypes) <- sub("^X", "", names(combined_haplotypes))

# Define the exact crosses we want to filter for
crosses <- c("CC001 x CC001", "CC019 x CC019", "CC040 x CC040")

# Create list to store filtered dataframes
filtered_data <- list()

for (cross in crosses) {
  # Get Animal.IDs for current cross
  cross_animals <- ControlPup$Animal.ID[ControlPup$Cross == cross]
  
  # Filter combined_haplotypes to only include columns for these animals
  # First, keep any non-sample columns (assuming they're in the beginning)
  non_sample_cols <- combined_haplotypes[, !grepl("^[A-Za-z0-9]", names(combined_haplotypes))]
  
  # Then filter for only the columns matching our animal IDs
  sample_cols <- combined_haplotypes[, cross_animals[cross_animals %in% names(combined_haplotypes)]]
  
  # Combine non-sample columns with filtered sample columns
  filtered_data[[cross]] <- cbind(non_sample_cols, sample_cols)
  
  # Get strain name for file naming
  strain <- sub(" x .*$", "", cross)
  
  # Write to CSV
  write.csv(filtered_data[[cross]], 
            file = paste0("Data/CC_indexes/filtered_haplotypes_", strain, ".csv"),
            row.names = FALSE)
}

# Print summary of filtered datasets
for (cross in crosses) {
  strain <- sub(" x .*$", "", cross)
  cat(sprintf("\nSummary for %s:\n", cross))
  # Subtract 1 to account for the gene names column
  cat(sprintf("Number of samples: %d\n", 
              ncol(filtered_data[[cross]]) - 1 - length(which(!grepl("^[A-Za-z0-9]", names(filtered_data[[cross]][-1]))))))
  cat(sprintf("Number of rows: %d\n", 
              nrow(filtered_data[[cross]])))}

# should be: good! 
# CC001: 29
# CC019: 32
# CC040: 9 
```

```{r}
# confirm output indexes have correct samples: filtered correctly 

CC001_haplo <- read.csv("Data/CC_indexes/filtered_haplotypes_CC001.csv")
names(CC001_haplo) <- sub("^X", "", names(CC001_haplo))

CC019_haplo <- read.csv("Data/CC_indexes/filtered_haplotypes_CC019.csv")
names(CC019_haplo) <- sub("^X", "", names(CC019_haplo))

CC040_haplo <- read.csv("Data/CC_indexes/filtered_haplotypes_CC040.csv")
names(CC040_haplo) <- sub("^X", "", names(CC040_haplo))
```

```{r}
#Saves hetero genes now as "AB", and using a 0.3-0.7 range for diallelic genes to determine heterozygosity 
# also, defining "concordant" cutoff as >95% of the haplotypes are homo for same allele (ie one sample can be mishaplotyped without removing that gene)

# Function to check concordance and create strain index
analyze_strain_data <- function(file_path) {
  # Read the strain-specific file
  data <- read.csv(file_path)
  
  # Get gene names and sample columns
  genes <- data[, 1]
  sample_data <- data[, -1]  # Exclude gene names column
  
  # Function to check if frequencies suggest heterozygosity or dominant concordance
  analyze_haplotypes <- function(row) {
    # Remove blank/empty haplotypes before analysis
    row <- row[!is.na(row) & row != ""]
    
    # If all values are blank/empty, return early
    if(length(row) == 0) {
      return(list(
        is_het = FALSE,
        is_dominant_concordant = FALSE,
        combined_haplotype = NA,
        frequencies = "No valid haplotypes"
      ))
    }
    
    # Get frequencies of remaining values
    value_counts <- table(row)
    freqs <- prop.table(value_counts)
    
    # Create named list for return values
    result <- list(
      is_het = FALSE,
      is_dominant_concordant = FALSE,
      combined_haplotype = NA,
      frequencies = paste(sprintf("%s (%.1f%%)", names(freqs), freqs * 100), collapse = ", ")
    )
    
    # Check for dominant concordance (>95%)
    if(any(freqs > 0.95)) {
      result$is_dominant_concordant <- TRUE
      result$combined_haplotype <- names(which.max(value_counts))
      return(result)
    }
    
    # Check if we have exactly 2 haplotypes
    if(length(freqs) == 2) {
      # Check if frequencies are roughly equal (between 0.3 and 0.7)
      if(all(freqs >= 0.3 & freqs <= 0.7)) {
        result$is_het <- TRUE
        # Take first letter of each haplotype and combine alphabetically
        hap1 <- substr(names(value_counts)[1], 1, 1)
        hap2 <- substr(names(value_counts)[2], 1, 1)
        result$combined_haplotype <- paste0(sort(c(hap1, hap2)), collapse = "")
      }
    }
    
    return(result)
  }
  
  # Process each gene
  results <- lapply(1:nrow(sample_data), function(i) {
    row <- sample_data[i,]
    # Filter out NA and blank values
    valid_values <- row[!is.na(row) & row != ""]
    
    # If no valid values remain, mark as discordant
    if(length(valid_values) == 0) {
      return(list(
        is_concordant = FALSE,
        concordance_type = NA,
        is_heterozygous = FALSE,
        haplotype = NA,
        status = "discordant",
        unique_haplotypes = "",
        num_unique_haplotypes = 0,
        haplotype_frequencies = "No valid haplotypes"
      ))
    }
    
    unique_values <- unique(valid_values)
    haplotype_analysis <- analyze_haplotypes(row)
    
    if(length(unique_values) == 1) {
      # Perfect concordance case
      return(list(
        is_concordant = TRUE,
        concordance_type = "perfect",
        is_heterozygous = FALSE,
        haplotype = unique_values[1],
        status = "concordant",
        unique_haplotypes = paste(unique_values, collapse = ","),
        num_unique_haplotypes = 1,
        haplotype_frequencies = haplotype_analysis$frequencies
      ))
    } else if(haplotype_analysis$is_dominant_concordant) {
      # Dominant concordance case (>95%)
      return(list(
        is_concordant = TRUE,
        concordance_type = "dominant",
        is_heterozygous = FALSE,
        haplotype = haplotype_analysis$combined_haplotype,
        status = "concordant",
        unique_haplotypes = paste(sort(unique_values), collapse = ","),
        num_unique_haplotypes = length(unique_values),
        haplotype_frequencies = haplotype_analysis$frequencies
      ))
    } else if(haplotype_analysis$is_het) {
      # Heterozygous case
      return(list(
        is_concordant = FALSE,
        concordance_type = NA,
        is_heterozygous = TRUE,
        haplotype = haplotype_analysis$combined_haplotype,
        status = "heterozygous",
        unique_haplotypes = paste(sort(unique_values), collapse = ","),
        num_unique_haplotypes = length(unique_values),
        haplotype_frequencies = haplotype_analysis$frequencies
      ))
    } else {
      # Discordant case
      return(list(
        is_concordant = FALSE,
        concordance_type = NA,
        is_heterozygous = FALSE,
        haplotype = NA,
        status = "discordant",
        unique_haplotypes = paste(sort(unique_values), collapse = ","),
        num_unique_haplotypes = length(unique_values),
        haplotype_frequencies = haplotype_analysis$frequencies
      ))
    }
  })
  
  # Convert results to data frames
  concordance_results <- data.frame(
    gene = genes,
    is_concordant = sapply(results, `[[`, "is_concordant"),
    concordance_type = sapply(results, `[[`, "concordance_type"),
    is_heterozygous = sapply(results, `[[`, "is_heterozygous"),
    unique_haplotypes = sapply(results, `[[`, "unique_haplotypes"),
    num_unique_haplotypes = sapply(results, `[[`, "num_unique_haplotypes"),
    haplotype_frequencies = sapply(results, `[[`, "haplotype_frequencies")
  )
  
  # Create strain index (only concordant and heterozygous genes)
  strain_index <- data.frame(
    gene = genes,
    haplotype = sapply(results, `[[`, "haplotype")
  )
  
  # Filter out discordant genes (where haplotype is NA)
  strain_index <- strain_index[!is.na(strain_index$haplotype), ]
  
  # Remove rows with blank/empty haplotypes
  strain_index <- strain_index[strain_index$haplotype != "", ]
  
  return(list(
    concordance = concordance_results,
    strain_index = strain_index
  ))
}

# Process each strain
strains <- c("CC001", "CC019", "CC040")
all_results <- list()

for(strain in strains) {
  file_path <- paste0("Data/CC_indexes/filtered_haplotypes_", strain, ".csv")
  results <- analyze_strain_data(file_path)
  all_results[[strain]] <- results
  
  # Print summary statistics
  cat(sprintf("\nResults for %s:\n", strain))
  cat(sprintf("Total genes analyzed: %d\n", nrow(results$concordance)))
  cat(sprintf("Perfect concordant genes: %d (%.1f%%)\n", 
              sum(na.omit(results$concordance$concordance_type == "perfect")),
              100 * mean(na.omit(results$concordance$concordance_type == "perfect"))))
  cat(sprintf("Dominant concordant genes (>95%%): %d (%.1f%%)\n", 
              sum(na.omit(results$concordance$concordance_type == "dominant")),
              100 * mean(na.omit(results$concordance$concordance_type == "dominant"))))
  cat(sprintf("Heterozygous genes: %d (%.1f%%)\n", 
              sum(results$concordance$is_heterozygous),
              100 * mean(results$concordance$is_heterozygous)))
  
  # Print distribution of gene statuses
  cat("\nDistribution of gene statuses:\n")
  status_table <- table(sapply(results, function(r) {
    if(is.list(r) && "status" %in% names(r)) {
      return(r$status)
    } else {
      return(NA)
    }
  }))
  
  print(status_table[c("concordant", "heterozygous", "discordant")])
  
  # Report number of blank haplotypes removed
  cat(sprintf("\nBlank haplotypes removed: %d\n",
              sum(!is.na(sapply(results, `[[`, "haplotype")) & 
                  sapply(results, `[[`, "haplotype") == "")))
  
  # Save results
  dir.create(paste0("Data/CC_indexes/", strain), showWarnings = FALSE, recursive = TRUE)
  write.csv(results$concordance,
            file = paste0("Data/CC_indexes/", strain, "/concordance_results.csv"),
            row.names = FALSE)
  write.csv(results$strain_index,
            file = paste0("Data/CC_indexes/", strain, "/strain_index.csv"),
            row.names = FALSE)
}


# Note: I did QC: understanding if any samples are driving the discordant_genes resulting in ~90% of my genes being concordant in each CC index 
# Don't think there were any sample mix-ups here 
```

## 4. CC Transition Probability Calculations

```{r}
cc.trans.probs_2 = function(snps, chr = c(1:19, "X"), sex = c("F", "M")) {
  curr.snps = which(snps$chr == chr)
  
  if(chr != 'X') {
    # Autosomal chromosomes - 8x8 matrix
    retval = array(0, c(length(1:8), length(1:8), length(curr.snps) - 1), 
                   dimnames = list(c('A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'),
                                 c('A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'),
                                 snps$marker[curr.snps[-1]]))  # Changed from genes to snps$marker
    r = diff(snps$cM[curr.snps]) * 1e-8  # Changed to use cM column directly
    r[r == 0] = 1e-8
    
    for(s in 1:(length(curr.snps)-1)) {
      retval[,,s] = log(r[s]) - log(1.0 + 6.0 * r[s])
      diag(retval[,,s]) = log(1.0 - r[s]) - log(1.0 + 6.0 * r[s])
    }
  } else {
    # X chromosome - 5x5 matrix for both sexes
    retval = array(0, c(length(1:5), length(1:5), length(curr.snps) - 1), 
                   dimnames = list(c('A', 'B', 'C', 'E', 'F'),
                                 c('A', 'B', 'C', 'E', 'F'),
                                 snps$marker[curr.snps[-1]]))  # Changed from genes to snps$marker
    genotype <- c('A', 'B', 'C', 'E', 'F')
    r = diff(snps$cM[curr.snps]) * 1e-8  # Changed to use cM column directly
    r[r == 0] = 1e-8
    
    for(s in 1:(length(curr.snps)-1)) {
      if(sex == "F") {
        # Female X chromosome calculations
         # Female X chromosome - inherited from both parents
        for (i in 1:nrow(retval[,,s])) {
          for (j in 1:ncol(retval[,,s])) {
            if (genotype[i] == genotype[j]) {
              if (genotype[i] == genotype[3]) {
                retval[,,s][i,j] = - log(1.0 + 4.0 * r[s])
              } else {
                retval[,,s][i,j] = log(1.0 - r[s]) - log(1.0 + 4.0 * r[s])
              }
            } else if (genotype[j] == genotype[3]) {
              retval[,,s][i,j] = log(2.0) + log(r[s]) - log(1.0 + 4.0 * r[s])
            } else {
              retval[,,s][i,j] = log(r[s]) - log(1.0 + 4.0 * r[s])
            }
          }
        }
      } else {
        # Male X chromosome calculations
        # Simpler transition probabilities due to hemizygosity
        # Male X chromosome - inherited only from mother
        for (i in 1:nrow(retval[,,s])) {
          for (j in 1:ncol(retval[,,s])) {
            if (genotype[i] == genotype[j]) {
              retval[,,s][i,j] = log(1.0 - r[s])
            } else {
              retval[,,s][i,j] = log(r[s]) - log(4.0)
            }
          }
        }
      }
    }
  }
  return(retval)
}
```

```{r}
# generate 8x8 for autosomes and 5x5 for X chromo h5 output files 

generate_female_transprobs <- function(snps) { 
  chromosomes = c(1:19, "X")
  h5file = 'tranprob.CC.G20.F.h5'
  h5createFile(h5file)
  sex = "F"
  
  for(chr in chromosomes) {
    # Get transition probabilities for this chromosome
    tprobs = cc.trans.probs_2(snps, chr=chr, sex=sex)
    # Write to h5 file using chromosome:generation:sex naming convention
    h5write(tprobs, file=h5file, name=paste(chr, "20", sex, sep=":"))
  }
}

generate_male_transprobs <- function(snps) { 
  chromosomes = c(1:19, "X")
  h5file = 'tranprob.CC.G20.M.h5'
  h5createFile(h5file)
  sex = "M"
  
  for(chr in chromosomes) {
    # Get transition probabilities for this chromosome
    tprobs = cc.trans.probs_2(snps, chr=chr, sex=sex)
    # Write to h5 file using chromosome:generation:sex naming convention
    h5write(tprobs, file=h5file, name=paste(chr, "20", sex, sep=":"))
  }
}

# Run both functions
generate_female_transprobs(snps)
generate_male_transprobs(snps)
```

## 5. CC-RIX Transition Probability Calculations

```{r}
# Key changes from CC:
# Added heterozygosity handling (gamma_scale) - updated to 0.5 since each parental CC line contributes one haplotype 
# incorporating CC strain "index" files, ie an avergaed output from the CC specific GBRS for CC001, CC019, and CC040, to refine the possible hetero diplotypes in CC-RIX samples. 
# Updated to generate 4 output file for each RIX (ie M/F for CC001xCC019 and M/F for CC019xCC001), since male pups only inherit X chromo from mom, need to account for that 

# older version not accounting for parental haplotypes yet 

cc_rix_trans_probs = function(snps, chr = c(1:19, "X"), sex = c("F", "M"), 
                             gamma_scale = 0.5,
                             strain1_haps, strain2_haps) {
  
  # Helper function for possible RIX genotypes
  get_possible_rix_genotypes = function(strain1_geno, strain2_geno) {
    strain1_alleles = strsplit(strain1_geno, "")[[1]]
    strain2_alleles = strsplit(strain2_geno, "")[[1]]
    possible_genos = c()
    for(allele1 in strain1_alleles) {
      for(allele2 in strain2_alleles) {
        geno = paste(sort(c(allele1, allele2)), collapse="")
        possible_genos = c(possible_genos, geno)
      }
    }
    return(unique(possible_genos))
  }
  
  curr.snps = which(snps$chr == chr)
  
  if(chr != 'X') {
    # Autosomal chromosomes calculations
    retval = array(0, c(length(1:8), length(1:8), length(curr.snps) - 1), 
                   dimnames = list(c('A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'),
                                 c('A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'),
                                 snps$marker[curr.snps[-1]]))
    
    r = diff(snps$cM[curr.snps]) * 1e-8
    r[r == 0] = 1e-8
    
    for(s in 1:(length(curr.snps)-1)) {
      # Get parental genotypes
      strain1_geno = strain1_haps$haplotype[s]
      strain2_geno = strain2_haps$haplotype[s]
      possible_genos = get_possible_rix_genotypes(strain1_geno, strain2_geno)
      
      # Base calculations
      retval[,,s] = log(r[s]) - log(1.0 + 6.0 * r[s])
      diag(retval[,,s]) = log(1.0 - r[s]) - log(1.0 + 6.0 * r[s])
      
      # Modify based on RIX possibilities
      for(i in 1:8) {
        for(j in 1:8) {
          base_prob = retval[i,j,s]
          if(paste0(LETTERS[i], LETTERS[i]) %in% possible_genos &&
             paste0(LETTERS[j], LETTERS[j]) %in% possible_genos) {
            retval[i,j,s] = base_prob - log(1.0 + gamma_scale)
          } else {
            retval[i,j,s] = base_prob - log(2.0)
          }
        }
      }
    }
    return(retval)
    
  } else {
    # X chromosome calculations
    retval = array(0, c(length(1:5), length(1:5), length(curr.snps) - 1), 
                   dimnames = list(c('A', 'B', 'C', 'E', 'F'),
                                 c('A', 'B', 'C', 'E', 'F'),
                                 snps$marker[curr.snps[-1]]))
    
    genotype <- c('A', 'B', 'C', 'E', 'F')
    r = diff(snps$cM[curr.snps]) * 1e-8
    r[r == 0] = 1e-8
    
    for(s in 1:(length(curr.snps)-1)) {
      if(sex == "F") {
        # Female X chromosome calculations
        for (i in 1:nrow(retval[,,s])) {
          for (j in 1:ncol(retval[,,s])) {
            if (genotype[i] == genotype[j]) {
              if (genotype[i] == genotype[3]) {
                retval[,,s][i,j] = - log(1.0 + 4.0 * r[s])
              } else {
                retval[,,s][i,j] = log(1.0 - r[s]) - log(1.0 + 4.0 * r[s])
              }
            } else if (genotype[j] == genotype[3]) {
              retval[,,s][i,j] = log(2.0) + log(r[s]) - log(1.0 + 4.0 * r[s])
            } else {
              retval[,,s][i,j] = log(r[s]) - log(1.0 + 4.0 * r[s])
            }
          }
        }
      } else {
        # Male X chromosome calculations
        for (i in 1:nrow(retval[,,s])) {
          for (j in 1:ncol(retval[,,s])) {
            if (genotype[i] == genotype[j]) {
              retval[,,s][i,j] = log(1.0 - r[s])
            } else {
              retval[,,s][i,j] = log(r[s]) - log(4.0)
            }
          }
        }
      }
    }
    return(retval)
  }
}
```

```{r}
# Key changes from CC:
# Added heterozygosity handling (gamma_scale) - updated to 0.5 since each parental CC line contributes one haplotype 
# incorporating CC strain "index" files, ie an avergaed output from the CC specific GBRS for CC001, CC019, and CC040, to refine the possible hetero diplotypes in CC-RIX samples. 
# Updated to generate 4 output file for each RIX (ie M/F for CC001xCC019 and M/F for CC019xCC001), since male pups only inherit X chromo from mom, need to account for that 
# note: this version is more explicit with how to handle the CC parental background info -- doing normalization after the fact 


# should be best version, but haven't gotten to work yet 

# Enhanced RIX transition probability function with detailed scenario handling
cc_rix_trans_probs = function(snps, chr = c(1:19, "X"), sex = c("F", "M"), 
                             gamma_scale = 0.5,
                             strain1_haps, strain2_haps) {
  
  # Helper function for possible RIX genotypes
  # This generates all possible offspring genotypes given two parental genotypes
  get_possible_offspring_genotypes = function(strain1_geno, strain2_geno) {
    strain1_alleles = strsplit(strain1_geno, "")[[1]]
    strain2_alleles = strsplit(strain2_geno, "")[[1]]
    possible_genos = c()
    
    # Generate all possible combinations by crossing parental alleles
    # This handles ALL parental scenarios (1-6) by systematically combining alleles
    for(allele1 in strain1_alleles) {
      for(allele2 in strain2_alleles) {
        # Create genotype and ensure consistent ordering (A before B, etc.)
        geno = paste(sort(c(allele1, allele2)), collapse="")
        possible_genos = c(possible_genos, geno)
      }
    }
    return(unique(possible_genos))
  }
  
  # Function to analyze which scenario we're dealing with
  # This is for documentation/debugging purposes
  identify_inheritance_scenario = function(strain1_geno, strain2_geno) {
    strain1_alleles = unique(strsplit(strain1_geno, "")[[1]])
    strain2_alleles = unique(strsplit(strain2_geno, "")[[1]])
    
    strain1_is_homo = length(strain1_alleles) == 1
    strain2_is_homo = length(strain2_alleles) == 1
    
    # Scenario 1: Both parents homozygous, same allele (AA × AA)
    if(strain1_is_homo && strain2_is_homo && strain1_alleles[1] == strain2_alleles[1]) {
      return(1)
    }
    # Scenario 2: Both parents homozygous, different alleles (AA × BB)
    else if(strain1_is_homo && strain2_is_homo && strain1_alleles[1] != strain2_alleles[1]) {
      return(2)
    }
    # Scenario 3: One parent homozygous, one heterozygous (AA × AB)
    else if((strain1_is_homo && !strain2_is_homo) || (!strain1_is_homo && strain2_is_homo)) {
      return(3)
    }
    # For the heterozygous scenarios, we need to check shared alleles
    else {
      # Count shared alleles
      shared_alleles = sum(strain1_alleles %in% strain2_alleles)
      
      # Scenario 4: Both parents heterozygous, same alleles (AB × AB)
      if(shared_alleles == 2) {
        return(4)
      }
      # Scenario 5: Both parents heterozygous, one shared allele (AB × AC)
      else if(shared_alleles == 1) {
        return(5)
      }
      # Scenario 6: Both parents heterozygous, no shared alleles (AB × CD)
      else {
        return(6)
      }
    }
  }
  
  curr.snps = which(snps$chr == chr)
  
  if(chr != 'X') {
    # Autosomal chromosomes calculations
    retval = array(0, c(length(1:8), length(1:8), length(curr.snps) - 1), 
                   dimnames = list(c('A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'),
                                 c('A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'),
                                 snps$marker[curr.snps[-1]]))
    
    r = diff(snps$cM[curr.snps]) * 1e-8
    r[r == 0] = 1e-8
    
    for(s in 1:(length(curr.snps)-1)) {
      # Get parental genotypes for this location
      strain1_geno = strain1_haps$haplotype[s]
      strain2_geno = strain2_haps$haplotype[s]
      
      # Identify which inheritance scenario we're dealing with (for documentation)
      scenario = identify_inheritance_scenario(strain1_geno, strain2_geno)
      
      # Generate all possible offspring genotypes based on parental genotypes
      # This systematically handles all scenarios (1-6)
      possible_offspring_genos = get_possible_offspring_genotypes(strain1_geno, strain2_geno)
      
      # Generate a lookup table for genotype to matrix index conversion
      # This converts between your string representation (like "AA", "AB") and matrix indices
      genotype_to_index = list()
      for(i in 1:8) {
        homo_geno = paste0(LETTERS[i], LETTERS[i])
        hetero_indices = sort(c(i, ifelse(i <= 4, i+4, i-4)))
        hetero_geno = paste0(LETTERS[hetero_indices[1]], LETTERS[hetero_indices[2]])
        genotype_to_index[[homo_geno]] = i 
        genotype_to_index[[hetero_geno]] = i
      }
      
      # Base calculations - initial recombination probabilities
      retval[,,s] = log(r[s]) - log(1.0 + 6.0 * r[s])
      diag(retval[,,s]) = log(1.0 - r[s]) - log(1.0 + 6.0 * r[s])
      
      # Now apply biological constraints based on the specific scenario
      # We modify transition probabilities based on what's biologically possible
      switch(scenario,
        # Scenario 1: Both parents homozygous, same allele (AA × AA)
        # Offspring should be 100% homozygous for that allele
        {
          # Get the only possible genotype (e.g., "AA")
          only_possible_geno = possible_offspring_genos[1]
          only_possible_index = genotype_to_index[[only_possible_geno]]
          
          # Set all transitions to essentially zero except self-transition for the possible genotype
          for(i in 1:8) {
            for(j in 1:8) {
              if(i == only_possible_index && j == only_possible_index) {
                # Keep the self-transition probability high
                # No change needed - diagonal already has high probability
              } else {
                # All other transitions are impossible
                retval[i,j,s] = -100  # effectively zero
              }
            }
          }
        },
        
        # Scenario 2: Both parents homozygous, different alleles (AA × BB)
        # Offspring should be 100% heterozygous (AB)
        {
          # Get the only possible genotype (e.g., "AB")
          only_possible_geno = possible_offspring_genos[1]
          only_possible_index = genotype_to_index[[only_possible_geno]]
          
          # Set all transitions to essentially zero except self-transition for the possible genotype
          for(i in 1:8) {
            for(j in 1:8) {
              if(i == only_possible_index && j == only_possible_index) {
                # Keep the self-transition probability high
                # No change needed - diagonal already has high probability
              } else {
                # All other transitions are impossible
                retval[i,j,s] = -100  # effectively zero
              }
            }
          }
        },
        
        # Scenario 3: One parent homozygous, one heterozygous (AA × AB)
        # Offspring can be either AA or AB with equal probability
        {
          # Get the possible genotype indices
          possible_indices = sapply(possible_offspring_genos, function(g) genotype_to_index[[g]])
          
          for(i in 1:8) {
            for(j in 1:8) {
              if(!(i %in% possible_indices) || !(j %in% possible_indices)) {
                # At least one genotype is impossible
                retval[i,j,s] = -100  # effectively zero
              }
              # Otherwise keep the base recombination probability
            }
          }
        },
        
        # Scenario 4: Both parents heterozygous, same alleles (AB × AB)
        # Offspring follow Mendelian 1:2:1 ratio (25% AA, 50% AB, 25% BB)
        {
          # Get the possible genotype indices
          possible_indices = sapply(possible_offspring_genos, function(g) genotype_to_index[[g]])
          
          for(i in 1:8) {
            for(j in 1:8) {
              if(!(i %in% possible_indices) || !(j %in% possible_indices)) {
                # At least one genotype is impossible
                retval[i,j,s] = -100  # effectively zero
              }
              # Otherwise keep the base recombination probability
              # Note: We could adjust probabilities based on Mendelian ratios here,
              # but normalization will handle the relative proportions
            }
          }
        },
        
        # Scenario 5: Both parents heterozygous, one shared allele (AB × AC)
        # Offspring possibilities with equal probability
        {
          # Get the possible genotype indices
          possible_indices = sapply(possible_offspring_genos, function(g) genotype_to_index[[g]])
          
          for(i in 1:8) {
            for(j in 1:8) {
              if(!(i %in% possible_indices) || !(j %in% possible_indices)) {
                # At least one genotype is impossible
                retval[i,j,s] = -100  # effectively zero
              }
              # Otherwise keep the base recombination probability
            }
          }
        },
        
        # Scenario 6: Both parents heterozygous, no shared alleles (AB × CD)
        # All hetero offspring, equal probability
        {
          # Get the possible genotype indices
          possible_indices = sapply(possible_offspring_genos, function(g) genotype_to_index[[g]])
          
          for(i in 1:8) {
            for(j in 1:8) {
              if(!(i %in% possible_indices) || !(j %in% possible_indices)) {
                # At least one genotype is impossible
                retval[i,j,s] = -100  # effectively zero
              }
              # Otherwise keep the base recombination probability
            }
          }
        }
      )
      
      # After applying biological constraints, normalize each row
      # This ensures valid probability distributions (rows sum to 1)
      for(i in 1:8) {
        # Convert to probability space
        probs = exp(retval[i,,s])
        # Check if all probabilities are essentially zero
        if(all(probs < 1e-40)) {
          # This could happen if we mistakenly marked all transitions as impossible
          # Set equal probabilities as a fallback
          retval[i,,s] = rep(-log(8), 8)
        } else {
          # Normalize to sum to 1
          probs = probs / sum(probs)
          # Convert back to log space
          retval[i,,s] = log(probs)
        }
      }
    }
    return(retval)
    
  } else {
    # X chromosome calculations
    retval = array(0, c(length(1:5), length(1:5), length(curr.snps) - 1), 
                   dimnames = list(c('A', 'B', 'C', 'E', 'F'),
                                 c('A', 'B', 'C', 'E', 'F'),
                                 snps$marker[curr.snps[-1]]))
    
    genotype <- c('A', 'B', 'C', 'E', 'F')
    r = diff(snps$cM[curr.snps]) * 1e-8
    r[r == 0] = 1e-8
    
    for(s in 1:(length(curr.snps)-1)) {
      # Get parental genotypes for this location
      strain1_geno = strain1_haps$haplotype[s]
      strain2_geno = strain2_haps$haplotype[s]
      
      # Generate possible offspring genotypes with sex-specific inheritance
      # For X chromosome, we need to handle males and females differently
      if(sex == "F") {
        # Female offspring inherit X from both parents
        possible_offspring_genos = get_possible_offspring_genotypes(strain1_geno, strain2_geno)
      } else {
        # Male offspring inherit X only from mother
        # Determine which strain is maternal based on cross direction
        # In a RIX cross like CC001xCC019, the first strain is maternal
        maternal_geno = strain1_geno
        possible_offspring_genos = strsplit(maternal_geno, "")[[1]]
        # Males are hemizygous - each allele represents a complete genotype
      }
      
      # Generate a lookup table for genotype to matrix index conversion
      genotype_to_index = list()
      for(i in 1:5) {
        if(sex == "F") {
          # Females can be homo or hetero
          homo_geno = paste0(genotype[i], genotype[i])
          genotype_to_index[[homo_geno]] = i
          
          # Add heterozygous mappings for females
          for(j in 1:5) {
            if(i < j) {
              hetero_geno = paste0(genotype[i], genotype[j])
              # Map this hetero genotype to the lower index for simplicity
              genotype_to_index[[hetero_geno]] = i
            }
          }
        } else {
          # Males are hemizygous - single letter represents genotype
          genotype_to_index[[genotype[i]]] = i
        }
      }
      
      # Base calculations for X chromosome with sex-specific inheritance
      if(sex == "F") {
        # Female X chromosome calculations
        for (i in 1:nrow(retval[,,s])) {
          for (j in 1:ncol(retval[,,s])) {
            if (genotype[i] == genotype[j]) {
              if (genotype[i] == genotype[3]) {
                retval[,,s][i,j] = - log(1.0 + 4.0 * r[s])
              } else {
                retval[,,s][i,j] = log(1.0 - r[s]) - log(1.0 + 4.0 * r[s])
              }
            } else if (genotype[j] == genotype[3]) {
              retval[,,s][i,j] = log(2.0) + log(r[s]) - log(1.0 + 4.0 * r[s])
            } else {
              retval[,,s][i,j] = log(r[s]) - log(1.0 + 4.0 * r[s])
            }
          }
        }
      } else {
        # Male X chromosome calculations
        # Males inherit X only from mother and are hemizygous
        for (i in 1:nrow(retval[,,s])) {
          for (j in 1:ncol(retval[,,s])) {
            if (genotype[i] == genotype[j]) {
              retval[,,s][i,j] = log(1.0 - r[s])
            } else {
              retval[,,s][i,j] = log(r[s]) - log(4.0)
            }
          }
        }
      }
      
      # Apply biological constraints based on possible genotypes
      # For X chromosome, consideration of sex-specific inheritance is crucial
      possible_indices = c()
      for(geno in possible_offspring_genos) {
        if(geno %in% names(genotype_to_index)) {
          possible_indices = c(possible_indices, genotype_to_index[[geno]])
        }
      }
      
      # If we have reciprocal crosses, X chromosome inheritance will differ for males
      # For females, reciprocal crosses should produce identical results
      # For males, X chromosome comes only from mother
      
      for(i in 1:5) {
        for(j in 1:5) {
          # Check if transition is biologically possible
          if(!(i %in% possible_indices) || !(j %in% possible_indices)) {
            # At least one genotype is biologically impossible
            retval[i,j,s] = -100  # effectively zero
          }
          # Otherwise keep the base probability from sex-specific calculation
        }
      }
      
      # Handle special case for male X chromosomes in reciprocal crosses
      if(sex == "M") {
        # Males have only one X chromosome from mother
        # In RIX cross, strain1 is maternal (e.g., CC001 in CC001xCC019)
        # For males, self-transitions should have high probability for maternal alleles
        # Transitions between maternal alleles should have recombination probability
        # Transitions to/from non-maternal alleles should be impossible
        
        # Identify maternal possible alleles
        maternal_alleles = strsplit(strain1_geno, "")[[1]]
        maternal_indices = sapply(maternal_alleles, function(a) {
          which(genotype == a)
        })
        
        # For male X, only transitions between maternal alleles are possible
        for(i in 1:5) {
          for(j in 1:5) {
            if(!(i %in% maternal_indices) || !(j %in% maternal_indices)) {
              # Transition involves non-maternal allele - impossible
              retval[i,j,s] = -100  # effectively zero
            }
            # Otherwise keep the base probability from male X calculation
          }
        }
      }
      
      # Normalize rows to ensure valid probability distributions
      for(i in 1:5) {
        # Convert to probability space
        probs = exp(retval[i,,s])
        # Check if all probabilities are essentially zero
        if(all(probs < 1e-40)) {
          # This could happen if we mistakenly marked all transitions as impossible
          # Set equal probabilities as a fallback
          retval[i,,s] = rep(-log(5), 5)
        } else {
          # Normalize to sum to 1
          probs = probs / sum(probs)
          # Convert back to log space
          retval[i,,s] = log(probs)
        }
      }
    }
    return(retval)
  }
}
```

```{r}
# RIX1 and RIX2 
# generate 8x8 for autosomes and 5x5 for X chromo h5 output files 

generate_rix_transprobs = function(snps, strain1, strain2, generation = 20) {
  # Read strain indexes
  strain1_num = sub("CC", "", strain1)
  strain2_num = sub("CC", "", strain2)
  strain1_haps = read.csv(sprintf("Data/CC_indexes/CC%s/strain_index.csv", strain1_num))
  strain2_haps = read.csv(sprintf("Data/CC_indexes/CC%s/strain_index.csv", strain2_num))
  
  chromosomes = c(1:19, "X")
  cross1_name = sprintf("RIX_%sx%s", strain1, strain2)
  cross2_name = sprintf("RIX_%sx%s", strain2, strain1)
  
  # Generate female files
  generate_female_rix_transprobs <- function() {
    h5file1 = sprintf('%s.F.h5', cross1_name)
    h5file2 = sprintf('%s.F.h5', cross2_name)
    h5createFile(h5file1)
    h5createFile(h5file2)
    sex = "F"
    
    for(chr in chromosomes) {
      # Get transition probabilities for this chromosome
      tprobs = cc_rix_trans_probs(snps, chr=chr, sex=sex, 
                                 gamma_scale=0.5,
                                 strain1_haps=strain1_haps, 
                                 strain2_haps=strain2_haps)
      
      # Same probs for both files for females
      # Use consistent naming format: chromosome:generation:sex
      dataset_name = paste(chr, generation, sex, sep=":")
      h5write(tprobs, file=h5file1, name=dataset_name)
      h5write(tprobs, file=h5file2, name=dataset_name)
    }
  }
  
  # Generate male files
  generate_male_rix_transprobs <- function() {
    h5file1 = sprintf('%s.M.h5', cross1_name)
    h5file2 = sprintf('%s.M.h5', cross2_name)
    h5createFile(h5file1)
    h5createFile(h5file2)
    sex = "M"
    
    for(chr in chromosomes) {
      # Use consistent naming format: chromosome:generation:sex
      dataset_name = paste(chr, generation, sex, sep=":")
      
      if(chr != "X") {
        # Autosomal chromosomes - same for both directions
        tprobs = cc_rix_trans_probs(snps, chr=chr, sex=sex, 
                                   gamma_scale=0.5,
                                   strain1_haps=strain1_haps, 
                                   strain2_haps=strain2_haps)
        h5write(tprobs, file=h5file1, name=dataset_name)
        h5write(tprobs, file=h5file2, name=dataset_name)
      } else {
        # X chromosome - different for each direction due to maternal inheritance
        # Cross1: strain1 maternal
        tprobs1 = cc_rix_trans_probs(snps, chr=chr, sex=sex, 
                                    gamma_scale=0.5,
                                    strain1_haps=strain1_haps, 
                                    strain2_haps=strain2_haps)
        h5write(tprobs1, file=h5file1, name=dataset_name)
        
        # Cross2: strain2 maternal
        tprobs2 = cc_rix_trans_probs(snps, chr=chr, sex=sex, 
                                    gamma_scale=0.5,
                                    strain1_haps=strain2_haps, 
                                    strain2_haps=strain1_haps)
        h5write(tprobs2, file=h5file2, name=dataset_name)
      }
    }
  }
  
  # Run both functions
  generate_female_rix_transprobs()
  generate_male_rix_transprobs()
}

# For RIX1 (CC001xCC019 and CC019xCC001)
generate_rix_transprobs(snps, strain1="CC001", strain2="CC019")
# Creates:
# - RIX_CC001xCC019.F.h5
# - RIX_CC001xCC019.M.h5
# - RIX_CC019xCC001.F.h5
# - RIX_CC019xCC001.M.h5

# For RIX2 (CC019xCC040 and CC040xCC019)
generate_rix_transprobs(snps, strain1="CC019", strain2="CC040")
# Creates:
# - RIX_CC019xCC040.F.h5
# - RIX_CC019xCC040.M.h5
# - RIX_CC040xCC019.F.h5
# - RIX_CC040xCC019.M.h5
```

## 6. CC 8x8 QC

```{python}
#QC

import h5py
import numpy as np

def analyze_cc_h5(cc_file, chromosome):
    """
    Analyze CC transition probability h5 files before parsing/expansion.
    
    Args:
        cc_file: Path to CC transition probability h5 file
        chromosome: Chromosome identifier (1-19 or X)
    """
    try:
        # Open h5 file
        with h5py.File(cc_file, 'r') as cc_h5:
            # Get the dataset for the specified chromosome
            cc_key = f"{chromosome}:20:F"  # Assuming generation 20, female
            cc_array = cc_h5[cc_key][:]
            
            # Basic array analysis
            print(f"\nChromosome {chromosome} - Original CC H5 File:")
            print(f"Array shape: {cc_array.shape}")
            
            # Expected matrix size varies by chromosome
            expected_size = 5 if chromosome == 'X' else 8
            if cc_array.shape[1] != expected_size or cc_array.shape[2] != expected_size:
                print(f"WARNING: Expected {expected_size}x{expected_size} matrices, got {cc_array.shape[1]}x{cc_array.shape[2]}")
            
            # Value distribution analysis
            print("\nValue ranges:")
            print(f"min: {np.min(cc_array):.4f}")
            print(f"max: {np.max(cc_array):.4f}")
            print(f"mean: {np.mean(cc_array):.4f}")
            
            print("\nPercentiles:")
            for p in [0, 25, 50, 75, 100]:
                print(f"{p}th percentile: {np.percentile(cc_array, p):.4f}")
            
            # Diagonal analysis
            diag_values = np.array([arr[np.diag_indices(expected_size)] for arr in cc_array])
            print("\nDiagonal elements:")
            print(f"mean: {np.mean(diag_values):.4f}")
            print(f"std: {np.std(diag_values):.4f}")
            
            # Sample first position diagonal values
            print("\nFirst position diagonal values:")
            print(diag_values[0])
            
            # Sample full matrix at first position
            print("\nFull matrix at first position:")
            print(cc_array[0])
            
            # Check for invalid values
            print("\nInvalid values check:")
            print(f"Inf values present: {np.isinf(cc_array).any()}")
            print(f"NaN values present: {np.isnan(cc_array).any()}")
            
            # Check matrix properties
            print("\nMatrix properties:")
            # Sum of each row/column should be close to 1 in probability space
            first_pos_matrix = np.exp(cc_array[0])  # Convert from log space
            row_sums = np.sum(first_pos_matrix, axis=1)
            col_sums = np.sum(first_pos_matrix, axis=0)
            print(f"Row sums (should be close to 1): {row_sums}")
            print(f"Column sums (should be close to 1): {col_sums}")
            
            # Symmetry check
            sym_diff = np.max(np.abs(cc_array - np.transpose(cc_array, (0, 2, 1))))
            print(f"\nSymmetry check (should be close to 0): {sym_diff:.4e}")
            
            print("------------------------")
            
    except Exception as e:
        print(f"Error processing chromosome {chromosome}: {str(e)}")

# Run analysis for autosomes and X chromosome
chromosomes = [str(i) for i in range(1, 20)] + ['X']

print("Analyzing CC h5 file transition probabilities before parsing/expansion...")
for chr in chromosomes:
    analyze_cc_h5("tranprob.CC.G20.F.h5", chr)
    
# h5 files are perfect, parsing function is where things are going wrong     
```

## 7. CC-RIX 8x8 QC

```{python}

# diagonal elements not extrememly low (~0.5, which is actually right since these are for F1s)
# row/column sums not 1 (this needs to be fixed)
# When you modify probabilities with your gamma_scale factor and other RIX-specific transformations, the matrices no longer maintain proper probability distributions (row sums don't equal 1).
# issue lies in CCRIX transprob function, where I applied RIX specific haplos, but didn't normalize afterwards, so values dont reflect a real 0-1 prob matrix 

#QC
import h5py
import numpy as np

def analyze_rix_h5(rix_file, chromosome, generation=20):
    """
    Analyze RIX transition probability h5 files.
    
    Args:
        rix_file: Path to RIX transition probability h5 file
        chromosome: Chromosome identifier (1-19 or X)
        generation: Generation number (default: 20)
    """
    try:
        # Extract cross and sex info from filename
        cross_info = rix_file.split('.')[0]
        sex = rix_file.split('.')[1]
        
        # Open h5 file
        with h5py.File(rix_file, 'r') as rix_h5:
            # Get the dataset for the specified chromosome
            rix_key = f"{chromosome}:{generation}:{sex}"
            rix_array = rix_h5[rix_key][:]
            
            # Basic array analysis
            print(f"\nChromosome {chromosome} - {cross_info} ({sex}):")
            print(f"Array shape: {rix_array.shape}")
            
            # Expected matrix size varies by chromosome
            expected_size = 5 if chromosome == 'X' else 8
            if rix_array.shape[0] != expected_size or rix_array.shape[1] != expected_size:
                print(f"WARNING: Expected {expected_size}x{expected_size} matrices, got {rix_array.shape[0]}x{rix_array.shape[1]}")
            
            # Value distribution analysis
            print("\nValue ranges:")
            print(f"min: {np.min(rix_array):.4f}")
            print(f"max: {np.max(rix_array):.4f}")
            print(f"mean: {np.mean(rix_array):.4f}")
            
            print("\nPercentiles:")
            for p in [0, 25, 50, 75, 100]:
                print(f"{p}th percentile: {np.percentile(rix_array, p):.4f}")
            
            # Diagonal analysis
            diag_values = np.array([arr[np.diag_indices(expected_size)] for arr in rix_array])
            print("\nDiagonal elements:")
            print(f"mean: {np.mean(diag_values):.4f}")
            print(f"std: {np.std(diag_values):.4f}")
            
            # Sample first position diagonal values
            print("\nFirst position diagonal values:")
            print(diag_values[0])
            
            # Sample full matrix at first position
            print("\nFull matrix at first position:")
            print(rix_array[0])
            
            # Check for invalid values
            print("\nInvalid values check:")
            print(f"Inf values present: {np.isinf(rix_array).any()}")
            print(f"NaN values present: {np.isnan(rix_array).any()}")
            
            # Check matrix properties
            print("\nMatrix properties:")
            # Sum of each row/column should be close to 1 in probability space
            first_pos_matrix = np.exp(rix_array[0])  # Convert from log space
            row_sums = np.sum(first_pos_matrix, axis=1)
            col_sums = np.sum(first_pos_matrix, axis=0)
            print(f"Row sums (should be close to 1): {row_sums}")
            print(f"Column sums (should be close to 1): {col_sums}")
            
            # Symmetry check - relevant for autosomal chromosomes
            if chromosome != 'X' or sex == 'F':
                sym_diff = np.max(np.abs(rix_array - np.transpose(rix_array, (0, 2, 1))))
                print(f"\nSymmetry check (should be close to 0): {sym_diff:.4e}")
            
            print("------------------------")
            
    except Exception as e:
        print(f"Error processing {rix_file}, chromosome {chromosome}: {str(e)}")

# Run analysis for all RIX files
def analyze_all_rix_files(generation=20):
    chromosomes = [str(i) for i in range(1, 20)] + ['X']
    rix_files = [
        "RIX_CC001xCC019.F.h5", "RIX_CC001xCC019.M.h5",
        "RIX_CC019xCC001.F.h5", "RIX_CC019xCC001.M.h5",
        "RIX_CC019xCC040.F.h5", "RIX_CC019xCC040.M.h5",
        "RIX_CC040xCC019.F.h5", "RIX_CC040xCC019.M.h5"
    ]
    
    print("Analyzing RIX h5 file transition probabilities...")
    
    # Check symmetry between reciprocal crosses
    print("\n--- CHECKING SYMMETRY BETWEEN RECIPROCAL CROSSES ---")
    reciprocal_pairs = [
        ("RIX_CC001xCC019.F.h5", "RIX_CC019xCC001.F.h5"),
        ("RIX_CC001xCC019.M.h5", "RIX_CC019xCC001.M.h5", "autosomal_only"),
        ("RIX_CC019xCC040.F.h5", "RIX_CC040xCC019.F.h5"),
        ("RIX_CC019xCC040.M.h5", "RIX_CC040xCC019.M.h5", "autosomal_only")
    ]
    
    for pair in reciprocal_pairs:
        file1, file2 = pair[0], pair[1]
        check_mode = pair[2] if len(pair) > 2 else "all"
        
        print(f"\nComparing {file1} vs {file2}")
        for chr in chromosomes:
            if check_mode == "autosomal_only" and chr == "X":
                print(f"Skipping X chromosome comparison for male files")
                continue
                
            try:
                with h5py.File(file1, 'r') as h5_1, h5py.File(file2, 'r') as h5_2:
                    sex = file1.split('.')[1]
                    key = f"{chr}:{generation}:{sex}"
                    
                    array1 = h5_1[key][:]
                    array2 = h5_2[key][:]
                    
                    if array1.shape != array2.shape:
                        print(f"  Chr {chr}: Shape mismatch! {array1.shape} vs {array2.shape}")
                        continue
                        
                    # For female X or autosomes, arrays should be identical
                    # For male X, they should differ
                    if chr != "X" or sex == "F":
                        max_diff = np.max(np.abs(array1 - array2))
                        print(f"  Chr {chr}: Max difference: {max_diff:.4e}")
                        if max_diff > 1e-10:
                            print(f"  WARNING: Reciprocal crosses differ for {chr}")
                    else:
                        # For male X chromosome, we expect differences
                        print(f"  Chr X (male): Different as expected due to maternal inheritance")
            except Exception as e:
                print(f"  Error comparing {chr}: {str(e)}")
    
    # Per-file analysis
    print("\n--- DETAILED ANALYSIS OF EACH FILE ---")
    for rix_file in rix_files:
        print(f"\nAnalyzing {rix_file}...")
        for chr in chromosomes:
            analyze_rix_h5(rix_file, chr, generation)

# Run the analysis
analyze_all_rix_files(generation=20)
```

## 8. Parse CC 8x8 to 36x36

```{r}
#parse_h5_transprob_to_npz.py
# run in Terminal 

# Make script executable
#chmod +x cc_parser.py

# Run for female file
#  python cc_parser.py -t tranprob.CC.G20.F.h5 -s F -g 20

# Run for male file
#  python cc_parser.py -t tranprob.CC.G20.M.h5 -s M -g 20

# feeling slighly better about this simply due to the fact that its taking a very long time to calculate the tprob epansion for each Chr 

# key realization: the abundance of -744 (initalization of extremely low proabability) is actually right, considering CC are inbred, they only have reasonable homo transitions, and hence the hetero transitions are effectly impossible 
# try using these CC files in GBRS reconstruct and see how it goes! consider G0 too as a shitty reference 

# takes ~ 1hr 40 mins 
```

## 9. Parse CC-RIX 8x8 to 36x36

```{r}

```

## 10. CC 36x36 QC

```{python}
# Comparing CC 8-state transprob files with GBRS_DATA DO 36-state transprob files

import numpy as np

def get_homo_indices(is_x=False):
    """Get correct indices for homozygous states in 36x36 matrix"""
    if is_x:
        return {
            'A': 0,   # AA
            'B': 8,   # BB
            'C': 15,  # CC
            'E': 26,  # EE
            'F': 30   # FF
        }
    else:
        return {
            'A': 0,   # AA
            'B': 8,   # BB
            'C': 15,  # CC
            'D': 21,  # DD
            'E': 26,  # EE
            'F': 30,  # FF
            'G': 33,  # GG
            'H': 35   # HH
        }

def detailed_analysis(cc_file, do_file, chromosome):
    """
    Compare CC and DO transition probability files with correct homozygous state indexing
    """
    try:
        cc_data = np.load(cc_file)
        do_data = np.load(do_file)
        
        cc_array = cc_data[chromosome]
        do_array = do_data[chromosome]
        
        # Basic array analysis
        print(f"\nChromosome {chromosome}:")
        print(f"Array dimensions:")
        print(f"CC array shape: {cc_array.shape}")
        print(f"DO array shape: {do_array.shape}")
        
        print(f"\nNumber of positions: CC={cc_array.shape[0]}, DO={do_array.shape[0]}")
        print("Value ranges:")
        print(f"CC - min: {np.min(cc_array):.10f}, max: {np.max(cc_array):.10f}, mean: {np.mean(cc_array):.10f}")
        print(f"DO - min: {np.min(do_array):.10f}, max: {np.max(do_array):.10f}, mean: {np.mean(do_array):.10f}")
        
        print("\nPercentiles:")
        for p in [0, 25, 50, 75, 100]:
            print(f"{p}th percentile - CC: {np.percentile(cc_array, p):.10f}, DO: {np.percentile(do_array, p):.10f}")
        
        # Get correct homozygous state indices
        homo_indices = get_homo_indices(chromosome == 'X')
        
        # Analyze diagonal elements
        cc_diag = np.array([arr[np.diag_indices(36)] for arr in cc_array])
        do_diag = np.array([arr[np.diag_indices(36)] for arr in do_array])
        
        print("\nDiagonal elements overall:")
        print(f"CC - mean: {np.mean(cc_diag):.10f}, std: {np.std(cc_diag):.10f}")
        print(f"DO - mean: {np.mean(do_diag):.10f}, std: {np.std(do_diag):.10f}")
        
        print("\nCC Individual diagonal means (homozygous states):")
        for founder, idx in homo_indices.items():
            cc_diagonal_mean = np.mean(cc_diag[:, idx])
            print(f"CC {founder}{founder}: {cc_diagonal_mean:.10f}")
            # Print first few values for verification
            if founder == 'A':  # Sample check
                print(f"  First 5 {founder}{founder} values: {cc_diag[:5, idx]}")
            
        print("\nDO Individual diagonal means (homozygous states):")
        for founder, idx in homo_indices.items():
            do_diagonal_mean = np.mean(do_diag[:, idx])
            print(f"DO {founder}{founder}: {do_diagonal_mean:.10f}")
        
        # Off-diagonal analysis
        off_diag_mask = ~np.eye(36, dtype=bool)
        cc_off_diag_mean = np.mean([arr[off_diag_mask] for arr in cc_array])
        do_off_diag_mean = np.mean([arr[off_diag_mask] for arr in do_array])
        
        print(f"\nOff-diagonal means:")
        print(f"CC: {cc_off_diag_mean:.10f}")
        print(f"DO: {do_off_diag_mean:.10f}")
        print("------------------------")
        
    except Exception as e:
        print(f"Error processing chromosome {chromosome}: {str(e)}")
        import traceback
        print(f"Stack trace:\n{traceback.format_exc()}")

# Run analysis for all chromosomes
chromosomes = [str(i) for i in range(1, 20)] + ['X']
for chr in chromosomes:
    detailed_analysis("tranprob.CC.G20.M.npz", "tranprob.DO.G20.M.npz", chr)
```

## 11. CC-RIX 36x36 QC

```{r}

```

## DONE

## 

## 
